#include <Rcpp.h>
#include <RcppEigen.h>
#include <Eigen/Core>
#include <Eigen/Dense>

// [[Rcpp::depends(RcppEigen)]]
using namespace Rcpp;
using Eigen::DiagonalMatrix;
using Eigen::Map;
using Eigen::MatrixXd;
using Eigen::VectorXd;


//' r-score
//' 
//' This function calculate r-score by given training set and test set. 
//' 
//' @param x A numeric matrix. The training set genotypic information matrix can be given as genotype matrix (coded by -1, 0, 1) or principle component matrix.
//' @param x0 A numeric mareix. The test set genotypic information matrix can be given as genotype matrix (coded by -1, 0, 1) or principle component matrix.
//' 
//' @return A floating-point number, r-score.
//' 
//' @references
//' @author Jen-Hsiang Ou
//' 
//' @import Rcpp
//' @import RcppEigen
//' @export
// [[Rcpp::export]]
float r_score(Eigen::MatrixXd x, Eigen::MatrixXd x0)
{
    int nr = x.rows();
    int nc = x.cols();
    int n0r = x0.rows();
    Eigen::MatrixXd A = x.transpose() * ((x * x.transpose() + MatrixXd::Identity(nr, nr) * (1.0 / nc)).inverse());
    Eigen::MatrixXd IJ = MatrixXd::Identity(n0r, n0r) - (MatrixXd::Identity(n0r, n0r) * (1.0 / n0r));
    float q1 = n0r - 1 + (IJ * x0).array().square().sum();
    Eigen::MatrixXd IJX0A = IJ * x0 * A;
    Eigen::MatrixXd IJX0AX = IJX0A * x;
    float q2 = IJX0A.array().square().sum() + IJX0AX.array().square().sum();
    float q12 = (x0.transpose() * IJX0AX).trace();
    return q12 / (sqrt(q1 * q2));
}